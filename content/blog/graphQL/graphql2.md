---
date: 2021-11-29 20:23:13
category: 'graphQL'
draft: false
title: '[GraphQL] GraphQL 과 RestAPI'
---

이 글은 Graph QL 공식 사이트의 'GraphQL is the better REST' 를 번역한 글입니다.

[원문 보기](https://www.howtographql.com/basics/1-graphql-is-the-better-rest/)

# Graph QL은 더 나은 REST

지난 10년간 REST는 웹 API설계를 위한 표준에 가까워 졌습니다. stateless server와 리소스에 대한 구조화된 접근같은 좋은 개념들을 제공한다. 그러나 RESP APIs는 클라이언트의 빠르게 변화하는 요구 사항을 따라가기에는 유연하지 못합니다.

그래프QL은 더 많은 유연성과 효율성에 대한 요구에 대처하기 위해 개발 되었다. 개발자가 REST API와 상호작용 할 때 경험하는 많은 단점과 비효율성을 해결 한다.

## 예제 시나리오

REST API와 Graph QL의 주요 차이점을 설명하기 위한 간단한 예제 시나리오이다. 블로그 앱은 특정 사용자의 게시물의 제목을 표시해야 한다. 같은 화면에 해당 사용자의 마지막 팔로워 3명의 이름도 표시가 된다.

REST API와 Graph QL을 사용한 시나리오 차이점을 비교한다.

### REST API로 데이터 가져 오기

일반적으로 여러 엔드포인트에서 데이터를 가져 온다.

1. 엔드포인드 : `/users/<id>` 에서 초기 사용자의 데이터를 리턴

2. 엔드포인트 : `/users/<id>/posts` 에서 사용자에 대한 모든 포스팅 데이터를 리턴

3. 엔드포인트 : `/users/<id>/followers` 에서 사용자당 팔로워 목록을 리턴

REST를 사용하면 필요한 데이터를 가져오기 위해서 서로 다른 엔드포인트에 요청을 세 번 해야 한다. 엔드포인트가 필요하지 않은 추가 정보를 반환하기 때문에 오버 페칭중이기도 하다.

![출처:[https://www.howtographql.com/basics/1-graphql-is-the-better-rest/](https://www.howtographql.com/basics/1-graphql-is-the-better-rest/)](graphql2/Untitled.png)

출처:[https://www.howtographql.com/basics/1-graphql-is-the-better-rest/](https://www.howtographql.com/basics/1-graphql-is-the-better-rest/)

### Graph QL로 데이터 가져오기

그래프 QL에서는 구체적인 데이터 요구 사항이 포함된 단일 쿼리를 Graph QL서버에 보내기만 하면 된다. 서버는 이러한 요구사항이 충족되는 JSON개체로 응답한다.

![출처: [https://www.howtographql.com/basics/1-graphql-is-the-better-rest/](https://www.howtographql.com/basics/1-graphql-is-the-better-rest/)](graphql2/g.png)

출처: [https://www.howtographql.com/basics/1-graphql-is-the-better-rest/](https://www.howtographql.com/basics/1-graphql-is-the-better-rest/)

REST API의 일반적인 문제인 오버 페치 및 언더 페치가 없어진다. 오버 및 언더 페치는 클라이언트가 데이터를 서버에서 받을 때 고정된 데이터 구조를 반환하는 엔드포인트에 접근하기 때문에 발생한다. 클라이언트에게 정확한 데이터 요구 사항을 제공할 수 있는 방식으로 API를 설계하는 것은 매우 어렵다.

## 오버 페치와 언더 페치

### 오버 페칭: 불필요한 데이터 다운로드

오버페칭은 클라이언트가 실제로 앱에서 필요한 것보다 더 많은 정보를 다운로드 하는 것을 말한다. 사용자 이름만 원하는데 /user 가 리턴하는 구조에 모든 사용자의 정보 (생일이나 주소)가 들어있으면 이것은 쓸데없는 정보가 된다.

### 언더 페칭과 n+1문제

언더페칭은 일반적으로 특정 엔드 포인트가 필요한 정보를 충분히 제공하지 않는다는 것을 말한다. 클라이언트는 필요한 모든 것을 가져오기 위해 추가 요청을 해야 한다. 이는 클라이언트가 먼저 요소 목록을 다운로드 해야 하지만 필요한 데이터를 가져오기 위해 요소당 하나의 추가 요청을 해야 하는 상황으로 확대될 수 있다.

예를들어 동일한 사용자 앱에서 마지막 3명의 팔로워를 표시해야 한다고 가정한다. API는 추가 엔드 포인트를 제공한다. `/users/<user-id>/followers .` 필요한 정보를 얻고자 한다면 앱이 `/users`에서 각 사용자 마다 `/users/<user-id>/followers`에 도달해야 한다.

## 프론트엔드에서 신속한 제품 반복?

REST API의 일반적인 패턴은 앱 내부에 있는 보기에 따라 엔드포인트를 구조화 하는 것이다. 이는 클라이언트가 해당 엔드포인트에 간단히 접근하여 특정 정보를 얻을수 있으므로 편리하다.

이 방식의 주요 단점은 프런트엔드에서 빠른 반복을 허용하지 않는다는 것이다. UI가 변경될 때 마다 이전보다 더 많은(혹은 더 적은)데이터가 필요할 위험이 높다. 결과적으로 새로운 데이터 요구 사항을 고려하여 백엔드도 조정해야 한다. 이는 생산성을 저하시키고 사용자 피드백을 제품에 통합 시키는 능력을 현저히 저하 시킨다.

그래프 QL을 사용한다면 이 문제가 해결 된다. 그래프 QL의 유연한 특성 덕분에 서버에서 추가 작업 없이 클라이언트 측에서 변경할 수 있다. 고객이 정확한 데이터 요구 사항을 지정할 수 있으므로 프런트엔드 설계 및 데이터 요구 사항이 변경될 때 백엔드 엔지니어가 조정할 필요가 없다.

## 백엔드에 대한 통찰력 있는 분석

Graph QL을 사용하면 백엔드에서 요청된 데이터에 대한 세부적인 통찰력을 얻을 수 있다. 각 클라이언트는 관심 있는 정보를 정확히 저장하므로 사용 가능한 데이터가 어떻게 사용되는지 깊이 이해할 수 있다. 예를들어 API를 발전시키고 클라이언트가 더이상 요청하지 않는 특정 필드를 더이상 사용하지 않는 데 도움이 될 수 있다.

Graph QL을 사용하면 서버에서 처리하는 요청에 대한 낮은 수준의 성능 모니터링도 수행할 수 있다. GraphQL은 클라이언트가 요청한 데이터를 수집하기 위해 resolver 함수를 사용한다. 이 리졸버 함수의 성능을 계측하고 측정하면 시스템의 병목 현상에 대한 통찰력을 얻을 수 있다.

## 스키마 및 유형 시스템의 이점

그래프 큐엘은 강력한 유형 시스템을 이용하여 API의 기능을 정의 한다. API 에 노출되는 모든 유형은 Graph QL SDL(스키마 정의 언어)을 사용하여 스키마에 기록 된다. 이 스키마는 클라이언트가 데이터에 엑세스 할 수 있는 방법을 정의하기 위해 클라이언트와 서버 간의 계약 역할을 한다.

스키마가 정의되면 프론트와 백엔드에서 작업하는 팀은 네트워크를 통해 전송되는 데이터의 명확한 구조를 알고 있기 때문에 추가 통신 없이 작업을 수행할 수 있따.

프론트엔드 팀은 필요한 데이터 구조를 조종하여 앱을 쉽게 테스트 가능하다. 서버가 준비되면 클라이언트 앱이 실제로 API에서 데이터를 로드하도록 스위칭 할 수 있다.
